---
title: "CS598 - Coding Assignment 4"
author: "Xiaoming Ji"
output: pdf_document
---

```{r, include=FALSE}
mypackages = c("recommenderlab", "ggplot2", "dplyr", "reshape2")   # required packages
tmp = setdiff(mypackages, rownames(installed.packages()))  # packages need to be installed
if (length(tmp) > 0) install.packages(tmp)
lapply(mypackages, require, character.only = TRUE)
```

## Step 1: Set the seed at the beginning of your code to be the last 4-dig of your University ID.
```{r}
set.seed(6682)
```

## Step 2: Create 

- *train data* that contains about 60% rows of the ratings.dat from the MovieLens 1M dataset (of the same format);
- *test data* that contains about 20% of the user-movie pairs from the ratings.dat from the MovieLens 1M dataset. 

```{r, include=FALSE}
ratings = read.csv('ratings.dat', sep = ':', 
    colClasses = c('integer', 'NULL'), header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')

ratings$Timestamp = NULL;
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.6)
train = ratings[train.id, ]

test = ratings[-train.id, ]
test.id = sample(nrow(test), floor(nrow(test)) * 0.5)
test = test[test.id, ]

label = test[c('UserID', 'Rating')]
test$Rating = NA
```

## Step 3: Build two models to predict the movie rating for each user-movie pair in the test data. 

```{r}
R = acast(train, UserID ~ MovieID, value.var = 'Rating')
R = as(R, 'realRatingMatrix')

models = list(
  UBCF = list(normalize = 'Z-score', method = 'cosine', nn = 5),
  SVDF = list(normalize = 'Z-score')
)
rmses = rep(0, length(models))

for (m in 1:length(models)) {
  rec = Recommender(R, method = names(models)[m],
      parameter = models[[m]])
  
  recom = predict(rec, R, type = 'ratings')
  rec_list = as(recom, 'list')
  
  # For all lines in test file, one by one
  for (u in 1:nrow(test)){
      userid = as.character(test$UserID[u])
      movieid = as.character(test$MovieID[u])
      
      rating = rec_list[[userid]][movieid]
      test$Rating[u] = ifelse(is.na(rating), 2.5, rating)
  }
  
  rmses[m] = RMSE(test$Rating, label$Rating)
}

end.time = Sys.time()
run.time = as.numeric(difftime(end.time, start.time, units = 'secs'))

print(run.time)
```

## Step 4: Report the RMSE (Root-mean-square error) of these two models on the test data. 

```{r include=FALSE}
rmses
```


```{r eval=FALSE, include=FALSE}
algorithms <- list(
  UBCF = list(name = "UBCF", param = NULL),
  SVDF = list(name = "SVD", param = NULL)
  #POPULAR = list(name = "POPULAR", param = NULL)
)

R.all = acast(ratings, UserID ~ MovieID, value.var = 'Rating')
R.all = as(R.all, 'realRatingMatrix')

es <- evaluationScheme(R.all, method="cross-validation", k=5, given=3)
ev <- evaluate(es, algorithms, type="ratings",progress=TRUE)
```

